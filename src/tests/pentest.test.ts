import request from 'supertest';
import app from '../app';

describe('BASIC PENETRATION TESTS', () => {
  // Test unauthenticated access to admin route
  it('should deny access to /admin/users when unauthenticated', async () => {
    const res = await request(app).get('/admin/users');
    expect([401, 403]).toContain(res.status);
  });

  // Simple SQL injection attempt on login
  it('should not allow SQL injection via login password field', async () => {
    const res = await request(app).post('/auth/login').send({
      email: 'filip.smet@medecare.be',
      password: "' OR '1'='1",
    });
    expect([401, 400]).toContain(res.status);
  });

  // Check for informational header leakage
  it('should not expose the X-Powered-By header', async () => {
    const res = await request(app).get('/');
    expect(res.headers['x-powered-by']).toBeUndefined();
  });

  // XSS attempt in user input fields
  it('should prevent XSS in user registration', async () => {
    const res = await request(app).post('/auth/register').send({
      email: 'test@example.com',
      password: 'password123',
      name: '<script>alert("XSS")</script>',
    });
    expect([400, 422]).toContain(res.status);
  });

  // Path traversal attempt
  it('should prevent directory traversal attacks', async () => {
    const res = await request(app).get('/files/../../etc/passwd');
    expect([400, 403, 404]).toContain(res.status);
  });

  // Test for sensitive information in error messages
  it('should not expose sensitive info in error messages', async () => {
    const res = await request(app).post('/auth/login').send({
      email: 'nonexistent@example.com',
      password: 'wrongpassword',
    });
    expect(res.body.message).not.toMatch(/database|sql|server|internal/i);
  });

  // Rate limiting test (basic brute force protection)
  it('should implement rate limiting on login attempts', async () => {
    const requests = Array(10)
      .fill(null)
      .map(() =>
        request(app).post('/auth/login').send({
          email: 'test@example.com',
          password: 'wrongpassword',
        })
      );

    const responses = await Promise.all(requests);
    const rateLimited = responses.some((res) => res.status === 429);
    expect(rateLimited).toBe(true);
  });

  // Security headers check
  it('should include security headers', async () => {
    const res = await request(app).get('/');
    expect(res.headers['x-content-type-options']).toBe('nosniff');
    expect(res.headers['x-frame-options']).toBeDefined();
    expect(res.headers['x-xss-protection']).toBeDefined();
  });

  // HTTPS redirect test (if applicable)
  it('should enforce HTTPS in production', async () => {
    if (process.env.NODE_ENV === 'production') {
      const res = await request(app).get('/').set('x-forwarded-proto', 'http');
      expect([301, 302]).toContain(res.status);
    }
  });

  // File upload vulnerability test
  it('should validate file uploads properly', async () => {
    const res = await request(app)
      .post('/upload')
      .attach('file', Buffer.from('<?php echo "test"; ?>'), 'malicious.php');
    expect([400, 403, 415]).toContain(res.status);
  });

  // Test for NoSQL injection (if using MongoDB)
  it('should prevent NoSQL injection attempts', async () => {
    const res = await request(app).post('/auth/login').send({
      email: { $ne: null },
      password: { $regex: '.*' },
    });
    expect([400, 401]).toContain(res.status);
  });

  // Privilege escalation test
  it('should prevent privilege escalation in user update', async () => {
    const res = await request(app).put('/users/profile').send({
      role: 'admin',
      isAdmin: true,
      permissions: ['all'],
    });
    expect([400, 401, 403]).toContain(res.status);
  });

  // Test for CORS misconfiguration
  it('should have proper CORS configuration', async () => {
    const res = await request(app)
      .get('/')
      .set('Origin', 'https://malicious-site.com');
    expect(res.headers['access-control-allow-origin']).not.toBe('*');
  });

  // Session management test
  it('should invalidate sessions on logout', async () => {
    // First login to get a session
    const loginRes = await request(app).post('/auth/login').send({
      email: 'valid@example.com',
      password: 'validpassword',
    });

    if (loginRes.status === 200) {
      const token = loginRes.body.token;

      // Logout
      await request(app)
        .post('/auth/logout')
        .set('Authorization', `Bearer ${token}`);

      // Try to use the token after logout
      const protectedRes = await request(app)
        .get('/profile')
        .set('Authorization', `Bearer ${token}`);

      expect([401, 403]).toContain(protectedRes.status);
    }
  });

  // Test for HTTP method tampering
  it('should only allow appropriate HTTP methods', async () => {
    const res = await request(app).trace('/');
    expect([405, 501]).toContain(res.status);
  });
});
